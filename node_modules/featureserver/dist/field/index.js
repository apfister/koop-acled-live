var _ = require('lodash')
var moment = require('moment')
var fieldMap = require('./field-map')
var createFieldAliases = require('./aliases')
var createStatFields = require('./statFields')

module.exports = { computeFieldsFromProperties: computeFieldsFromProperties, computeFieldObject: computeFieldObject, createStatFields: createStatFields, createFieldAliases: createFieldAliases }

var templates = {
  server: require('../../templates/server.json'),
  layer: require('../../templates/layer.json'),
  features: require('../../templates/features.json'),
  statistics: require('../../templates/statistics.json'),
  field: require('../../templates/field.json'),
  objectIDField: require('../../templates/oid-field.json')
}

// TODO this should be the only exported function
function computeFieldObject (data, template, options) {
  if ( options === void 0 ) options = {};

  var oid = false
  var metadata = data.metadata || {}
  var metadataFields = metadata.fields

  if (!metadataFields && data.statistics) { return computeFieldsFromProperties(data.statistics[0], template, options).fields }
  else if (!metadataFields) { return computeAggFieldObject(data, template, options) }

  if (options.outFields && options.outFields !== '*') {
    var outFields = options.outFields.split(/\s*,\s*/)
    metadataFields = metadata.fields.filter(function (field) {
      if (outFields.indexOf(field.name) > -1) { return field }
    })
  }
  var fields = metadataFields.map(function (field) {
    var type
    if (field.name === metadata.idField || field.name.toLowerCase() === 'objectid') {
      type = 'esriFieldTypeOID'
      oid = true
    }
    var template = _.cloneDeep(templates.field)
    return Object.assign({}, template, {
      name: field.name,
      type: type || fieldMap[field.type.toLowerCase()] || field.type,
      alias: field.alias || field.name
    })
  })
  if (!oid) { fields.push(templates.objectIDField) }
  return fields
}

/** @type {Array} accepted date formats used by moment.js */
var DATE_FORMATS = [moment.ISO_8601]

/**
 * builds esri json fields object from geojson properties
 *
 * @param  {object} props
 * @param  {string} template
 * @param  {object} options
 * @return {object} fields
 */
function computeFieldsFromProperties (props, template, options) {
  if ( options === void 0 ) options = {};

  var fields = Object.keys(props).map(function (key, i) {
    var type = fieldType(props[key])
    var field = { name: key, type: type, alias: key }

    if (type === 'esriFieldTypeString') { field.length = 128 }
    else if (type === 'esriFieldTypeDate') { field.length = 36 }
    return field
  })
  if (template === 'layer' && Object.keys(props).indexOf('OBJECTID') < 0) {
    fields.push({
      name: 'OBJECTID',
      type: 'esriFieldTypeOID',
      alias: 'OBJECTID'
    })
  }

  return { oidField: 'OBJECTID', fields: fields }
}

/**
 * returns esri field type based on type of value passed
 *
 * @param {*} value - object to evaluate
 * @return {string} esri field type
 */
function fieldType (value) {
  var type = typeof value

  if (type === 'number') {
    return isInt(value) ? 'esriFieldTypeInteger' : 'esriFieldTypeDouble'
  } else if (typeof value === 'string' && moment(value, DATE_FORMATS, true).isValid()) {
    return 'esriFieldTypeDate'
  } else {
    return 'esriFieldTypeString'
  }
}

/**
 * is the value an integer?
 *
 * @param  {Number} value
 * @return {Boolean} is it an integer
 */
function isInt (value) {
  return Math.round(value) === value
}

function computeAggFieldObject (data, template, options) {
  if ( options === void 0 ) options = {};

  var feature = data.features && data.features[0]
  var properties = feature ? feature.properties || feature.attributes : options.attributeSample
  if (properties) { return computeFieldsFromProperties(properties, template, options).fields }
  else { return [] }
}
