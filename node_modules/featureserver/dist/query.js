var Winnow = require('winnow')
var ref = require('./templates');
var renderFeatures = ref.renderFeatures;
var renderStatistics = ref.renderStatistics;
var renderStats = ref.renderStats;
var Utils = require('./utils')

module.exports = query

/**
 * processes params based on query params
 *
 * @param {object} data
 * @param {object} params
 * @param {function} callback
 */
function query (data, params) {
  if ( params === void 0 ) params = {};

  // TODO clean up this series of if statements
  if (data.filtersApplied && data.filtersApplied.geometry) { delete params.geometry }
  if ((data.filtersApplied && data.filtersApplied.where) || params.where === '1=1') { delete params.where }
  if (data.statistics) { return renderStats(data) }
  if (params.returnCountOnly && data.count) { return { count: data.count } }

  if (params.f !== 'geojson') { params.toEsri = true }
  var queriedData = Winnow.query(data, params)

  if (params.f === 'geojson') { return { type: 'FeatureCollection', features: queriedData.features } }
  else { return geoservicesPostQuery(data, queriedData, params) }
}

function geoservicesPostQuery (data, queriedData, params) {
  // options.objectIds works alongside returnCountOnly but not statistics
  var oidField = (data.metadata && data.metadata.idField) || 'OBJECTID'
  if (params.objectIds && !params.outStatistics) {
    var oids

    if (typeof params.objectIds === 'string') { oids = params.objectIds.split(',') }
    else if (typeof params.objectIds === 'number') { oids = [params.objectIds] }
    else { oids = params.objectIds }

    oids = oids.map(function (i) {
      return parseInt(i)
    })
    queriedData.features = queriedData.features.filter(function (f) {
      return oids.indexOf(f.attributes[oidField]) > -1
    })
  }

  if (params.returnCountOnly) {
    return { count: queriedData.features.length }
  } else if (params.returnIdsOnly) {
    return idsOnly(queriedData, data.metadata)
  } else if (params.outStatistics) {
    return queryStatistics(queriedData, params)
  } else {
    params.extent = Utils.getExtent(queriedData)
    params.geometryType = Utils.getGeomType(data)
    // TODO should these be calculated using the whole dataset?
    params.spatialReference = params.outSR
    params.attributeSample = data.features[0] && data.features[0].properties
    return renderFeatures(queriedData, params)
  }
}

function idsOnly (data, options) {
  if ( options === void 0 ) options = {};

  var oidField = options.idField || 'OBJECTID'
  return data.features.reduce(
    function (resp, f) {
      resp.objectIds.push(f.attributes[oidField])
      return resp
    },
    { objectIdField: oidField, objectIds: [] }
  )
}

function queryStatistics (data, params) {
  // This little dance is in place because the stat response from Winnow is different
  // TODO make winnow come out as expected
  // or move this into templates.render
  var statResponse = {
    type: 'FeatureCollection',
    features: []
  }
  var features = Array.isArray(data) ? data : [data]
  statResponse.features = features.map(function (row) {
    return { attributes: row }
  })
  return renderStatistics(statResponse, params)
}
