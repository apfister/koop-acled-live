var OPERATORS = ['>', '<', '=', '>=', '<=', 'like', 'ilike', 'in', 'is']

/**
 * Creates a viable SQL where clause from a passed in SQL (from a url "where" param)
 *
 * @param {string} where - a sql where clause
 * @param {Array} fields - a list of fields in to support coded value domains
 * @return {string} sql
 */
function createClause (options) {
  options = options || {}
  if (!options.where) { return '' }
  var tokens = tokenize(options.where)
  if (options.esriFields) {
    tokens = decodeDomains(tokens, options.esriFields)
  }
  return translate(tokens, options)
}

/**
 * Take arbitrary sql and turns it into a consistent set of tokens
 */
function tokenize (sql) {
  // normalize all the binary expressions
  sql = pad(sql)
  var temp
  // find any multi-word tokens and replace the spaces with a special character
  // note: only 1 or 2 word tokens are accepted. Anything larger does not work
  var regex = /['"]\S+\s\S+['"]/g
  while ((temp = regex.exec(sql)) !== null) {
    var field = temp[0].replace(/\s/, '|@')
    sql = sql.replace(temp[0], field)
  }
  return sql.split(' ')
}

/**
 * Normalize binary operations to consistent spacing
 */
function pad (sql) {
  var operators = [
    {regex: />=/g, string: '>='},
    {regex: /<=/g, string: '<='},
    {regex: /=/g, string: '='},
    {regex: />(?!=)/g, string: '>'},
    {regex: /<(?!=)/g, string: '<'}
  ]
  var padded = operators.reduce(function (statement, op) {
    var pad = statement.replace(op.regex, (" " + (op.string) + " "))
    // ugly hack because javascripts haz no lookbehind
    return pad.replace(/> =/, '>=').replace(/< =/, '<=').replace(/i like/, 'ilike')
  }, sql)
  return padded.replace(/\s\s/g, ' ')
}

/**
 * Iterate through all tokens and replace values that belong to a coded domain
 * @param {array} tokens - a set of tokens for a sql where clause
 * @param {array} fields - the set of fields from a geoservices compatible service
 * @return {array} a set of tokens where any coded values have been decoded
 */
function decodeDomains (tokens, fields) {
  return tokens.map(function (token, i) {
    if (i < 2) { return token }
    var left = tokens[i - 2]
    var middle = tokens[i - 1]
    var right = token
    // if this set of 3 tokens makes a binary operation then check if we need to apply a domain
    if (isBinaryOp(left, middle, right)) { return applyDomain(left, right, fields) }
    else { return token }
  })
}

/**
 * Check whether 3 tokens make up a binary operation
 */
function isBinaryOp (left, middle, right) {
  if (!left || !middle || !right) { return false }
  return OPERATORS.indexOf(middle) > -1
}

/**
 * Check for any coded values in the fields
 * if we find a match, replace value with the coded val
 *
 * @param {string} fieldName - the name of field to look for
 * @param {number} value - the coded value
 * @param {Array} fields - a list of fields to use for coded value replacements
 */
function applyDomain (fieldName, value, fields) {
  var field = fields.filter(function (f) { return f.name === fieldName })[0]
  if (!field) { return value }
  var domain = field.domain
  if (domain && domain.codedValues) {
    var decoded = domain.codedValues.filter(function (cv) { return value.match(cv.code) })[0].name
    return typeof decoded === 'string' ? ("'" + decoded + "'") : decoded
  } else {
    return value
  }
}

/**
 * Translate tokens to be compatible with postgres json
 */
function translate (tokens, options) {
  var parts = tokens.map(function (token, i) {
    var middle = tokens[i + 1]
    if (!middle) { return token }
    // if this is a field name wrap it in postgres json
    var left = jsonify(token, middle, options)
    var right = removeTrailingParen(tokens[i + 2])
    // if this is a numeric operation cast to float
    return cast(left, middle, right)
  })
  return parts.join(' ').replace(/\|@/g, ' ')
}

/**
 * Cast a JSON selector to float if this is a numeric operation
 */
function cast (left, middle, right) {
  var numericOp = ['>', '<', '=', '>=', '<='].indexOf(middle) > -1 && isNumeric(right)
  if (numericOp) { return left }
  else { return left }
}

/**
 * Removes the trailing parameter from a sql token
 */
function removeTrailingParen (token) {
  if (!token) { return undefined }
  var paren = token.indexOf(')') > -1
  if (paren) { return token.slice(0, paren) }
  else { return token }
}

/**
 * Apply JSON selectors where appropriate
 */
function jsonify (token, next, options) {
  options = options || {}
  var leading = ''
  var lastPar = token.lastIndexOf('(')
  if (lastPar > -1) {
    leading = token.slice(0, lastPar + 1)
    token = token.slice(lastPar + 1, token.length)
  }
  var trailingParens = token.match(/\)+\s*$/)
  var trailing = ''
  if (trailingParens) {
    trailing = trailingParens[0]
    token = token.slice(0, trailingParens.index)
  }
  var selector = options.esri ? 'attributes' : 'properties'
  if (next) { next = next.toLowerCase() }
  var field = token.replace(/'|"/g, '')
  if (OPERATORS.indexOf(next) > -1 && field !== '1') { return ("" + leading + selector + "->`" + field + "`" + trailing) }
  else { return leading + token + trailing }
}

function isNumeric (num) {
  return (num >= 0 || num < 0)
}

module.exports = { createClause: createClause }
